pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";


library _LiquidityPools {
    using SafeMath for uint;

    struct State {
        // token -> deposit term -> PoolGroup
        mapping(address => mapping(uint => PoolGroup)) poolGroups;
    }

    struct PoolGroup {
        bool isInitialized;

        uint firstPoolId;
        uint lastPoolId;

        // pool id -> Pool
        mapping(uint => Pool) poolsById;

        // loan term -> total loanable amount
        mapping(uint => uint) totalLoanableAmountByTerm;
    }

    struct Pool {
        // Total amount deposited to this pool
        uint depositAmount;

        // Total amount borrowed from this pool
        uint borrowedAmount;

        // Total amount that can be borrowed from this pool
        uint availableAmount;

        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint loanInterest;
    }

    function initPoolGroupIfNeeded(
        State storage self,
        address tokenAddress,
        uint depositTerm
    )
        external
    {
        if (!self.poolGroups[tokenAddress][depositTerm].isInitialized) {
            /// The length of the PoolGroup should be (depositTerm + 1) because
            /// a deposit will mature in (depositTerm + 1) days.
            /// In other words, lastPoolId - firstPoolId = depositTerm
            self.poolGroups[tokenAddress][depositTerm] = PoolGroup({
                isInitialized: true,
                firstPoolId: 0,
                lastPoolId: depositTerm
            });
        }
    }
}
