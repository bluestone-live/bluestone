pragma solidity ^0.5.0;

import 'openzeppelin-solidity/contracts/math/SafeMath.sol';
import 'openzeppelin-solidity/contracts/math/Math.sol';
import '../../lib/FixedMath.sol';
import './_LoanManager.sol';

library _LiquidityPools {
    using SafeMath for uint256;
    using FixedMath for uint256;

    struct State {
        // token -> deposit term -> PoolGroup
        mapping(address => mapping(uint256 => PoolGroup)) poolGroups;
    }

    struct PoolGroup {
        bool isInitialized;
        uint256 firstPoolId;
        uint256 lastPoolId;
        // pool id -> Pool
        mapping(uint256 => Pool) poolsById;
        // loan term -> available amount to borrow
        mapping(uint256 => uint256) availableAmountByTerm;
    }

    struct Pool {
        // Total amount deposited to this pool
        uint256 depositAmount;
        // Total amount borrowed from this pool
        uint256 borrowedAmount;
        // Total amount that can be borrowed from this pool
        uint256 availableAmount;
        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint256 loanInterest;
    }

    struct LocalVars {
        uint256 loanTerm;
        address loanTokenAddress;
        uint256 loanAmount;
        uint256 loanInterest;
        uint256 depositTerm;
        uint256 remainingLoanAmount;
        uint256 availableAmountFromAllPoolGroups;
        uint256 availableAmountFromThisPoolGroup;
        uint256 loanAmountFromThisPoolGroup;
        uint256 numAvailablePoolGroups;
        uint256 remainder;
    }

    function initPoolGroupIfNeeded(
        State storage self,
        address tokenAddress,
        uint256 depositTerm
    ) external {
        if (!self.poolGroups[tokenAddress][depositTerm].isInitialized) {
            /// The length of the PoolGroup should be (depositTerm + 1) because
            /// a deposit will mature in (depositTerm + 1) days.
            /// In other words, lastPoolId - firstPoolId = depositTerm
            self.poolGroups[tokenAddress][depositTerm] = PoolGroup({
                isInitialized: true,
                firstPoolId: 0,
                lastPoolId: depositTerm
            });
        }
    }

    function updatePoolGroupDepositMaturity(
        State storage self,
        address tokenAddress,
        uint256 depositTerm,
        uint256[] calldata loanTermList
    ) external {
        PoolGroup storage poolGroup = self
            .poolGroups[tokenAddress][depositTerm];

        /// For every loan term N <= current deposit term, subtract N-th pool's availableAmount from
        /// availableAmountByTerm since that amount will not be available after shifting pools.
        for (uint256 i = 0; i < loanTermList.length; i++) {
            if (loanTermList[i] <= depositTerm) {
                uint256 loanTerm = loanTermList[i];
                uint256 poolId = poolGroup.firstPoolId + loanTerm;
                uint256 availableAmountOfPool = poolGroup.poolsById[poolId]
                    .availableAmount;
                poolGroup.availableAmountByTerm[loanTerm] = poolGroup
                    .availableAmountByTerm[loanTerm]
                    .sub(availableAmountOfPool);
            }
        }

        // Free storage of pool to be removed and get some gas refund
        delete poolGroup.poolsById[poolGroup.firstPoolId];

        // Increment pool IDs to reflect the deposit maturity change
        poolGroup.firstPoolId++;
        poolGroup.lastPoolId++;
    }

    function addDepositToPool(
        State storage self,
        address tokenAddress,
        uint256 depositAmount,
        uint256 depositTerm,
        uint256[] calldata loanTermList
    ) external returns (uint256 poolId) {
        PoolGroup storage poolGroup = self
            .poolGroups[tokenAddress][depositTerm];
        Pool storage pool = poolGroup.poolsById[poolGroup.lastPoolId];
        pool.depositAmount = pool.depositAmount.add(depositAmount);
        pool.availableAmount = pool.availableAmount.add(depositAmount);

        // Add deposit amount to availableAmountByTerm for every loan term <= this deposit term
        for (uint256 i = 0; i < loanTermList.length; i++) {
            uint256 loanTerm = loanTermList[i];

            if (loanTerm <= depositTerm) {
                poolGroup.availableAmountByTerm[loanTerm] = poolGroup
                    .availableAmountByTerm[loanTerm]
                    .add(depositAmount);
            }
        }

        return poolGroup.lastPoolId;
    }

    function loanFromPoolGroups(
        State storage self,
        _LoanManager.State storage loanManager,
        bytes32 loanId,
        uint256[] calldata depositTerms
    ) external {
        _LoanManager.LoanRecord storage loanRecord = loanManager
            .loanRecordById[loanId];
        LocalVars memory localVars;

        // Calculate total loanable amount from available pool groups
        for (uint256 i = 0; i < depositTerms.length; i++) {
            localVars.depositTerm = depositTerms[i];

            if (loanRecord.loanTerm > localVars.depositTerm) {
                continue;
            }

            localVars.availableAmountFromThisPoolGroup = self
                .poolGroups[loanRecord.loanTokenAddress][localVars.depositTerm]
                .availableAmountByTerm[loanRecord.loanTerm];

            localVars.availableAmountFromAllPoolGroups = localVars
                .availableAmountFromAllPoolGroups
                .add(localVars.availableAmountFromThisPoolGroup);

            localVars.numAvailablePoolGroups++;
        }

        // Check if we have sufficient amount to lend out
        require(
            loanRecord.loanAmount <= localVars.availableAmountFromAllPoolGroups,
            'Insufficient amount for loan'
        );

        localVars.remainingLoanAmount = loanRecord.loanAmount;

        // Loan from available pool groups
        for (uint256 i = 0; i < depositTerms.length; i++) {
            localVars.depositTerm = depositTerms[i];

            if (loanRecord.loanTerm > localVars.depositTerm) {
                continue;
            }

            if (localVars.numAvailablePoolGroups == 1) {
                // This is the last pool group left, so loan the remaining amount from it
                _loanFromPoolGroup(
                    self,
                    loanManager,
                    loanId,
                    localVars.depositTerm
                );
                break;
            }

            localVars.availableAmountFromThisPoolGroup = self
                .poolGroups[loanRecord.loanTokenAddress][localVars.depositTerm]
                .availableAmountByTerm[loanRecord.loanTerm];

            // Calculate amount to be loaned from this pool group, proportionally to its availableAmountByTerm
            localVars.loanAmountFromThisPoolGroup = loanRecord
                .loanAmount
                .mulFixed(localVars.availableAmountFromThisPoolGroup)
                .divFixed(localVars.availableAmountFromAllPoolGroups);

            /// If there is non-zero remainder for the above calculation, it means we have precision-loss after
            /// 18 decimal places. So loaners will receive loan amount less than what they asked for.
            /// We fix this issue in the next step.
            localVars.remainder = loanRecord
                .loanAmount
                .mulFixed(localVars.availableAmountFromThisPoolGroup)
                .mod(localVars.availableAmountFromAllPoolGroups);

            if (localVars.remainder > 0) {
                /// Compensate the precision-loss by adding one (wei) to the loan amount. If the result exceeds the
                /// maximum amount this pool group can provide, we take full loanable amount from this pool group.
                /// This strategy fixes the precision-loss issue while prevents overdraw from any pool group.
                localVars.loanAmountFromThisPoolGroup = Math.min(
                    localVars.loanAmountFromThisPoolGroup.add(1),
                    localVars.availableAmountFromThisPoolGroup
                );
            }

            _loanFromPoolGroup(
                self,
                loanManager,
                loanId,
                localVars.depositTerm
            );

            localVars.remainingLoanAmount = localVars.remainingLoanAmount.sub(
                localVars.loanAmountFromThisPoolGroup
            );

            localVars.numAvailablePoolGroups--;
        }
    }

    function repayLoanToPoolGroup(
        State storage self,
        _LoanManager.State storage loanManager,
        bytes32 loanId,
        uint256 repayAmount,
        uint256 depositTerm
    ) external {
        _LoanManager.LoanRecord storage loanRecord = loanManager
            .loanRecordById[loanId];
        PoolGroup storage poolGroup = self.poolGroups[loanRecord
            .loanTokenAddress][depositTerm];

        uint256 remainingRepayAmount = repayAmount;

        // Repay loan back to each pool, proportional to the total loan from all pools
        for (uint256 poolIndex = 0; poolIndex < depositTerm; poolIndex++) {
            if (remainingRepayAmount == 0) {
                // Stop loop when remaining repay amount is cleared up
                break;
            }

            uint256 poolId = poolGroup.firstPoolId + poolIndex;
            uint256 loanAmountFromThisPool = loanRecord
                .loanAmountByPool[depositTerm][poolId];

            if (loanAmountFromThisPool == 0) {
                // Skip this pool since it has no loan
                continue;
            }

            /// Calculate the amount to repay to this pool, e.g., if I loaned total of 100
            /// from all pools, where 10 is from this pool, and I want to repay 50 now.
            /// Then the amount pay back to this pool will be: 50 * 10 / 100 = 5
            uint256 repayAmountToThisPool = repayAmount
                .mulFixed(loanAmountFromThisPool)
                .divFixed(loanRecord.loanAmount);

            Pool storage pool = poolGroup.poolsById[poolId];
            pool.availableAmount = pool.availableAmount.add(
                repayAmountToThisPool
            );
            pool.borrowedAmount = pool.borrowedAmount.sub(
                repayAmountToThisPool
            );

            remainingRepayAmount = remainingRepayAmount.sub(
                repayAmountToThisPool
            );

            // Add repay amount to availableAmountByTerm for every loan term <= current term the pool refers to
            for (uint256 i = 0; i < loanManager.loanTermList.length; i++) {
                uint256 loanTerm = loanManager.loanTermList[i];

                if (loanTerm <= poolIndex + 1) {
                    poolGroup.availableAmountByTerm[loanTerm] = poolGroup
                        .availableAmountByTerm[loanTerm]
                        .add(repayAmountToThisPool);
                }
            }
        }

    }

    function getPool(
        State storage self,
        address tokenAddress,
        uint256 depositTerm,
        uint256 poolIndex
    )
        external
        view
        returns (
            uint256 depositAmount,
            uint256 borrowedAmount,
            uint256 availableAmount,
            uint256 loanInterest
        )
    {
        PoolGroup storage poolGroup = self
            .poolGroups[tokenAddress][depositTerm];
        return
            getPoolById(
                self,
                tokenAddress,
                depositTerm,
                poolGroup.firstPoolId + poolIndex
            );
    }

    function getPoolById(
        State storage self,
        address tokenAddress,
        uint256 depositTerm,
        uint256 poolId
    )
        public
        view
        returns (
            uint256 depositAmount,
            uint256 borrowedAmount,
            uint256 availableAmount,
            uint256 loanInterest
        )
    {
        PoolGroup storage poolGroup = self
            .poolGroups[tokenAddress][depositTerm];
        Pool storage pool = poolGroup.poolsById[poolId];

        return (
            pool.depositAmount,
            pool.borrowedAmount,
            pool.availableAmount,
            pool.loanInterest
        );
    }

    /// Loan from pool on left-hand side, then right-hand side, move pointers towards middle
    /// and repeat until loan amount is fulfilled.
    ///
    /// For example,
    /// if loan term is 1 and deposit term is 7, the sequence is:
    /// 0, 6, 1, 5, 2, 4, 3
    ///
    /// if loan term is 7 and deposit term is 30, the sequence is:
    /// 6, 29, 7, 28, 8, 27, ..., 16, 19, 17, 18
    function _loanFromPoolGroup(
        State storage self,
        _LoanManager.State storage loanManager,
        bytes32 loanId,
        uint256 depositTerm
    ) internal {
        _LoanManager.LoanRecord storage loanRecord = loanManager
            .loanRecordById[loanId];
        PoolGroup storage poolGroup = self.poolGroups[loanRecord
            .loanTokenAddress][depositTerm];
        uint256 remainingLoanAmount = loanRecord.loanAmount;

        // Mark left, right and current pool id
        uint256 left = poolGroup.firstPoolId + loanRecord.loanTerm;
        uint256 right = poolGroup.lastPoolId;
        uint256 poolId = left;
        bool onLeftSide = true;

        while (remainingLoanAmount > 0 && left <= right) {
            Pool storage pool = poolGroup.poolsById[poolId];

            if (pool.availableAmount > 0) {
                uint256 loanAmountFromPool = Math.min(
                    remainingLoanAmount,
                    pool.availableAmount
                );
                uint256 loanInterestToPool = loanRecord
                    .interest
                    .mulFixed(loanAmountFromPool)
                    .divFixed(loanRecord.loanAmount);

                pool.borrowedAmount = pool.borrowedAmount.add(
                    loanAmountFromPool
                );
                pool.availableAmount = pool.availableAmount.sub(
                    loanAmountFromPool
                );
                pool.loanInterest = pool.loanInterest.add(loanInterestToPool);

                // Record the actual pool we loan from, so we know which pool to repay back later
                loanRecord
                    .loanAmountByPool[depositTerm][poolId] = loanAmountFromPool;

                remainingLoanAmount = remainingLoanAmount.sub(
                    loanAmountFromPool
                );
            }

            // Switch side
            if (onLeftSide) {
                // In an odd-number pool group, we need to stop when we reach the last pool in the middle
                if (left == right) {
                    break;
                }

                poolId = right;
                onLeftSide = false;
            } else {
                // Update left and right pointers as both have been loaned
                left++;
                right--;

                poolId = left;
                onLeftSide = true;
            }
        }

        // Subtract loan amount from availableAmountByTerm for every loan term <= this loan term
        for (uint256 i = 0; i < loanManager.loanTermList.length; i++) {
            uint256 loanTerm = loanManager.loanTermList[i];

            if (loanTerm <= loanRecord.loanTerm) {
                poolGroup.availableAmountByTerm[loanTerm] = poolGroup
                    .availableAmountByTerm[loanTerm]
                    .sub(loanRecord.loanAmount);
            }
        }
    }
}
