pragma solidity ^0.5.0;

import 'openzeppelin-solidity/contracts/math/SafeMath.sol';

library _LiquidityPools {
    using SafeMath for uint256;

    struct State {
        // token -> deposit term -> PoolGroup
        mapping(address => mapping(uint256 => PoolGroup)) poolGroups;
    }

    struct PoolGroup {
        bool isInitialized;
        uint256 firstPoolId;
        uint256 lastPoolId;
        // pool id -> Pool
        mapping(uint256 => Pool) poolsById;
        // loan term -> available amount to borrow
        mapping(uint256 => uint256) availableAmountByTerm;
    }

    struct Pool {
        // Total amount deposited to this pool
        uint256 depositAmount;
        // Total amount borrowed from this pool
        uint256 borrowedAmount;
        // Total amount that can be borrowed from this pool
        uint256 availableAmount;
        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint256 loanInterest;
    }

    function initPoolGroupIfNeeded(
        State storage self,
        address tokenAddress,
        uint256 depositTerm
    ) external {
        if (!self.poolGroups[tokenAddress][depositTerm].isInitialized) {
            /// The length of the PoolGroup should be (depositTerm + 1) because
            /// a deposit will mature in (depositTerm + 1) days.
            /// In other words, lastPoolId - firstPoolId = depositTerm
            self.poolGroups[tokenAddress][depositTerm] = PoolGroup({
                isInitialized: true,
                firstPoolId: 0,
                lastPoolId: depositTerm
            });
        }
    }

    function updatePoolGroupDepositMaturity(
        State storage self,
        address tokenAddress,
        uint256 depositTerm,
        uint256[] calldata loanTermList
    ) external {
        PoolGroup storage poolGroup = self
            .poolGroups[tokenAddress][depositTerm];

        /// For every loan term N <= current deposit term, subtract N-th pool's availableAmount from
        /// availableAmountByTerm since that amount will not be available after shifting pools.
        for (uint256 i = 0; i < loanTermList.length; i++) {
            if (loanTermList[i] <= depositTerm) {
                uint256 loanTerm = loanTermList[i];
                uint256 poolId = poolGroup.firstPoolId + loanTerm;
                uint256 availableAmountOfPool = poolGroup.poolsById[poolId]
                    .availableAmount;
                poolGroup.availableAmountByTerm[loanTerm] = poolGroup
                    .availableAmountByTerm[loanTerm]
                    .sub(availableAmountOfPool);
            }
        }

        // Free storage of pool to be removed and get some gas refund
        delete poolGroup.poolsById[poolGroup.firstPoolId];

        // Increment pool IDs to reflect the deposit maturity change
        poolGroup.firstPoolId++;
        poolGroup.lastPoolId++;
    }

    function addDepositToPool(
        State storage self,
        address tokenAddress,
        uint256 depositAmount,
        uint256 depositTerm,
        uint256[] calldata loanTermList
    ) external returns (uint256 poolId) {
        PoolGroup storage poolGroup = self
            .poolGroups[tokenAddress][depositTerm];
        Pool storage pool = poolGroup.poolsById[poolGroup.lastPoolId];
        pool.depositAmount = pool.depositAmount.add(depositAmount);
        pool.availableAmount = pool.availableAmount.add(depositAmount);

        // Add deposit amount to availableAmountByTerm for every loan term <= this deposit term
        for (uint256 i = 0; i < loanTermList.length; i++) {
            uint256 loanTerm = loanTermList[i];

            if (loanTerm <= depositTerm) {
                poolGroup.availableAmountByTerm[loanTerm] = poolGroup
                    .availableAmountByTerm[loanTerm]
                    .add(depositAmount);
            }
        }

        return poolGroup.lastPoolId;
    }

    function getPool(
        State storage self,
        address tokenAddress,
        uint256 depositTerm,
        uint256 poolIndex
    )
        external
        view
        returns (
            uint256 depositAmount,
            uint256 borrowedAmount,
            uint256 availableAmount,
            uint256 loanInterest
        )
    {
        PoolGroup storage poolGroup = self
            .poolGroups[tokenAddress][depositTerm];
        Pool storage pool = poolGroup.poolsById[poolGroup.firstPoolId +
            poolIndex];

        return (
            pool.depositAmount,
            pool.borrowedAmount,
            pool.availableAmount,
            pool.loanInterest
        );
    }
}
