pragma solidity ^0.6.0;

import '../../lib/Math.sol';
import '../../lib/SafeMath.sol';
import '../../lib/FixedMath.sol';
import '../../lib/DateTime.sol';
import './LoanManager.sol';

library LiquidityPools {
    using SafeMath for uint256;
    using FixedMath for uint256;

    event PrintLog(string indexed key, uint256 value);

    struct State {
        // token -> PoolGroup
        mapping(address => PoolGroup) poolGroups;
    }

    struct PoolGroup {
        uint256 numPools;
        // Pool ID (in day) -> Pool
        mapping(uint256 => Pool) poolsById;
    }

    struct Pool {
        // Total amount deposited to this pool
        uint256 depositAmount;
        // Total amount that can be borrowed from this pool
        uint256 availableAmount;
        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint256 loanInterest;
        // Total deposit weight
        uint256 totalDepositWeight;
        /// We store interest disribution ratios when the very first deposit is made and
        /// they can't be changed afterwards to ensure correct interest calculation
        uint256 depositDistributorFeeRatio;
        uint256 loanDistributorFeeRatio;
        uint256 protocolReserveRatio;
    }

    function setPoolGroupSizeIfNeeded(
        State storage self,
        address tokenAddress,
        uint256 numPools
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];

        // We can only increase the number of pools
        if (numPools > poolGroup.numPools) {
            poolGroup.numPools = numPools;
        }
    }

    function addDepositToPool(
        State storage self,
        address tokenAddress,
        uint256 depositAmount,
        uint256 depositTerm,
        uint256 depositWeight,
        uint256 depositDistributorFeeRatio,
        uint256 loanDistributorFeeRatio,
        uint256 protocolReserveRatio
    ) external returns (uint256 poolId) {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        poolId = DateTime.toDays().add(depositTerm);
        Pool storage pool = poolGroup.poolsById[poolId];
        pool.depositAmount = pool.depositAmount.add(depositAmount);
        pool.availableAmount = pool.availableAmount.add(depositAmount);
        pool.totalDepositWeight = pool.totalDepositWeight.add(depositWeight);

        // Record ratios for interest disribution if they have not been set
        if (
            pool.depositDistributorFeeRatio == 0 &&
            pool.loanDistributorFeeRatio == 0 &&
            pool.protocolReserveRatio == 0
        ) {
            pool.depositDistributorFeeRatio = depositDistributorFeeRatio;
            pool.loanDistributorFeeRatio = loanDistributorFeeRatio;
            pool.protocolReserveRatio = protocolReserveRatio;
        }

        return poolId;
    }

    function subtractDepositFromPool(
        State storage self,
        address tokenAddress,
        uint256 depositAmount,
        uint256 depositWeight,
        uint256 poolId
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        Pool storage pool = poolGroup.poolsById[poolId];
        pool.depositAmount = pool.depositAmount.sub(depositAmount);
        pool.availableAmount = pool.availableAmount.sub(depositAmount);
        pool.totalDepositWeight = pool.totalDepositWeight.sub(depositWeight);
    }

    function loanFromPools(
        State storage self,
        LoanManager.LoanRecord storage loanRecord
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[loanRecord
            .loanTokenAddress];
        uint256 remainingLoanAmount = loanRecord.loanAmount;
        uint256 availableAmount = getAvailableAmountByLoanTerm(
            self,
            loanRecord.loanTokenAddress,
            loanRecord.loanTerm
        );

        require(
            availableAmount >= remainingLoanAmount,
            'LiquidityPools: invalid loan amount'
        );

        uint256 distributorInterest;
        uint256 firstPoolId = DateTime.toDays();

        for (
            uint256 poolId = firstPoolId + loanRecord.loanTerm;
            poolId <= firstPoolId + poolGroup.numPools;
            poolId++
        ) {
            if (remainingLoanAmount == 0) {
                break;
            }

            Pool storage pool = poolGroup.poolsById[poolId];

            if (pool.availableAmount == 0) {
                continue;
            }

            uint256 loanAmountFromPool = Math.min(
                remainingLoanAmount,
                pool.availableAmount
            );

            uint256 loanInterestToPool = loanRecord
                .interest
                .mul(loanAmountFromPool)
                .div(loanRecord.loanAmount);

            uint256 distributorInterestFromPool = pool
                .loanDistributorFeeRatio
                .mulFixed(loanInterestToPool);

            pool.availableAmount = pool.availableAmount.sub(loanAmountFromPool);
            pool.loanInterest = pool.loanInterest.add(loanInterestToPool);

            // Add up interest for loan distributor
            distributorInterest = distributorInterest.add(
                distributorInterestFromPool
            );

            // Record the actual pool we loan from, so we know which pool to repay back later
            loanRecord.loanAmountByPool[poolId] = loanAmountFromPool;

            remainingLoanAmount = remainingLoanAmount.sub(loanAmountFromPool);
        }

        // Save total loan distributor interest into loan record
        loanRecord.distributorInterest = distributorInterest;
    }

    function repayLoanToPools(
        State storage self,
        LoanManager.LoanRecord storage loanRecord,
        uint256 repayAmount
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[loanRecord
            .loanTokenAddress];

        uint256 remainingRepayAmount = repayAmount;
        uint256 firstPoolId = DateTime.toDays();

        // Repay loan back to each pool, proportional to the total loan from all pools
        uint256 loanAmountFromThisPool;
        uint256 repayAmountToThisPool;
        for (
            uint256 poolId = firstPoolId;
            poolId <= firstPoolId + poolGroup.numPools;
            poolId++
        ) {
            if (remainingRepayAmount == 0) {
                break;
            }
            loanAmountFromThisPool = loanRecord.loanAmountByPool[poolId];

            if (loanAmountFromThisPool == 0) {
                // Skip this pool since it has no loan
                continue;
            }

            /// Calculate the amount to repay to this pool, e.g., if I loaned total of 100
            /// from all pools, where 10 is from this pool, and I want to repay 50 now.
            /// Then the amount pay back to this pool will be: 50 * 10 / 100 = 5
            repayAmountToThisPool = repayAmount
                .mulFixed(loanAmountFromThisPool)
                .divFixed(loanRecord.loanAmount);

            Pool storage pool = poolGroup.poolsById[poolId];
            pool.availableAmount = pool.availableAmount.add(
                repayAmountToThisPool
            );

            remainingRepayAmount = remainingRepayAmount.sub(
                repayAmountToThisPool
            );
        }
    }

    function getPool(
        State storage self,
        address tokenAddress,
        uint256 poolIndex
    )
        external
        view
        returns (
            uint256 depositAmount,
            uint256 availableAmount,
            uint256 loanInterest,
            uint256 totalDepositWeight,
            uint256 depositDistributorFeeRatio,
            uint256 loanDistributorFeeRatio,
            uint256 protocolReserveRatio
        )
    {
        return
            getPoolById(self, tokenAddress, DateTime.toDays().add(poolIndex));
    }

    function getPoolById(
        State storage self,
        address tokenAddress,
        uint256 poolId
    )
        public
        view
        returns (
            uint256 depositAmount,
            uint256 availableAmount,
            uint256 loanInterest,
            uint256 totalDepositWeight,
            uint256 depositDistributorFeeRatio,
            uint256 loanDistributorFeeRatio,
            uint256 protocolReserveRatio
        )
    {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        Pool storage pool = poolGroup.poolsById[poolId];

        return (
            pool.depositAmount,
            pool.availableAmount,
            pool.loanInterest,
            pool.totalDepositWeight,
            pool.depositDistributorFeeRatio,
            pool.loanDistributorFeeRatio,
            pool.protocolReserveRatio
        );
    }

    function getDetailsFromAllPools(State storage self, address tokenAddress)
        external
        view
        returns (
            uint256[] memory poolIdList,
            uint256[] memory depositAmountList,
            uint256[] memory availableAmountList,
            uint256[] memory loanInterestList,
            uint256[] memory totalDepositWeightList
        )
    {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        poolIdList = new uint256[](poolGroup.numPools + 1);
        depositAmountList = new uint256[](poolGroup.numPools + 1);
        availableAmountList = new uint256[](poolGroup.numPools + 1);
        loanInterestList = new uint256[](poolGroup.numPools + 1);
        totalDepositWeightList = new uint256[](poolGroup.numPools + 1);
        uint256 firstPoolId = DateTime.toDays();

        for (
            uint256 poolIndex = 0;
            poolIndex <= poolGroup.numPools;
            poolIndex++
        ) {
            uint256 poolId = firstPoolId + poolIndex;
            poolIdList[poolIndex] = poolId;
            depositAmountList[poolIndex] = poolGroup.poolsById[poolId]
                .depositAmount;
            loanInterestList[poolIndex] = poolGroup.poolsById[poolId]
                .loanInterest;
            availableAmountList[poolIndex] = poolGroup.poolsById[poolId]
                .availableAmount;
            totalDepositWeightList[poolIndex] = poolGroup.poolsById[poolId]
                .totalDepositWeight;
        }

        return (
            poolIdList,
            depositAmountList,
            availableAmountList,
            loanInterestList,
            totalDepositWeightList
        );
    }

    function getAvailableAmountByLoanTerm(
        State storage self,
        address tokenAddress,
        uint256 loanTerm
    ) public view returns (uint256 availableAmountByLoanTerm) {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        uint256 availableAmount;

        for (
            uint256 poolIndex = loanTerm;
            poolIndex <= poolGroup.numPools;
            poolIndex++
        ) {
            uint256 poolId = DateTime.toDays().add(poolIndex);
            availableAmount = availableAmount.add(
                poolGroup.poolsById[poolId].availableAmount
            );
        }

        return availableAmount;
    }
}
