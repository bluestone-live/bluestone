pragma solidity ^0.5.0;

import 'openzeppelin-solidity/contracts/math/SafeMath.sol';
import 'openzeppelin-solidity/contracts/math/Math.sol';
import '../../lib/FixedMath.sol';
import './LoanManager.sol';

library LiquidityPools {
    using SafeMath for uint256;
    using FixedMath for uint256;

    struct State {
        // token -> PoolGroup
        mapping(address => PoolGroup) poolGroups;
    }

    struct PoolGroup {
        bool isInitialized;
        uint256 numPools;
        uint256 firstPoolId;
        // pool id -> Pool
        mapping(uint256 => Pool) poolsById;
    }

    struct Pool {
        // Total amount deposited to this pool
        uint256 depositAmount;
        // Total amount borrowed from this pool
        uint256 borrowedAmount;
        // Total amount that can be borrowed from this pool
        uint256 availableAmount;
        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint256 loanInterest;
        // Total deposit weight
        uint256 totalDepositWeight;
    }

    struct LocalVars {
        uint256 loanTerm;
        address loanTokenAddress;
        uint256 loanAmount;
        uint256 loanInterest;
        uint256 depositTerm;
        uint256 remainingLoanAmount;
        uint256 availableAmountFromAllPoolGroups;
        uint256 availableAmountFromThisPoolGroup;
        uint256 loanAmountFromThisPoolGroup;
        uint256 numAvailablePoolGroups;
        uint256 remainder;
    }

    function initPoolGroupIfNeeded(
        State storage self,
        address tokenAddress,
        uint256 numPools
    ) external {
        if (!self.poolGroups[tokenAddress].isInitialized) {
            /// The length of the PoolGroup should be (numPools + 1) because
            /// a deposit will mature in (numPools + 1) days.
            /// We can get the last pool ID using (firstPoolId + numPools).
            self.poolGroups[tokenAddress] = PoolGroup({
                isInitialized: true,
                numPools: numPools,
                firstPoolId: 0
            });
        }
    }

    function setPoolGroupSize(
        State storage self,
        address tokenAddress,
        uint256 numPools
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];

        require(
            poolGroup.isInitialized,
            'LiquidityPools: pool group is not initialized'
        );

        // Reduce number of pools is not allowed
        require(
            numPools > poolGroup.numPools,
            'LiquidityPools: invalid numPools'
        );

        poolGroup.numPools = numPools;
    }

    function updatePoolGroupDepositMaturity(
        State storage self,
        address tokenAddress
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];

        // Free storage of pool to be removed and get some gas refund
        delete poolGroup.poolsById[poolGroup.firstPoolId];

        // Increment pool IDs to reflect the deposit maturity change
        poolGroup.firstPoolId++;
    }

    function addDepositToPool(
        State storage self,
        address tokenAddress,
        uint256 depositAmount,
        uint256 depositTerm,
        uint256 depositWeight
    ) external returns (uint256 poolId) {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        poolId = poolGroup.firstPoolId + depositTerm;
        Pool storage pool = poolGroup.poolsById[poolId];
        pool.depositAmount = pool.depositAmount.add(depositAmount);
        pool.availableAmount = pool.availableAmount.add(depositAmount);
        pool.totalDepositWeight = pool.totalDepositWeight.add(depositWeight);

        return poolId;
    }

    function subtractDepositFromPool(
        State storage self,
        address tokenAddress,
        uint256 depositAmount,
        uint256 depositWeight,
        uint256 poolId
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        Pool storage pool = poolGroup.poolsById[poolId];
        pool.depositAmount = pool.depositAmount.sub(depositAmount);
        pool.availableAmount = pool.availableAmount.sub(depositAmount);
        pool.totalDepositWeight = pool.totalDepositWeight.sub(depositWeight);
    }

    function loanFromPools(
        State storage self,
        LoanManager.LoanRecord storage loanRecord
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[loanRecord
            .loanTokenAddress];
        uint256 remainingLoanAmount = loanRecord.loanAmount;
        uint256 availableAmount = getAvailableAmountByLoanTerm(
            self,
            loanRecord.loanTokenAddress,
            loanRecord.loanTerm
        );

        require(
            availableAmount >= remainingLoanAmount,
            'LiquidityPools: invalid loan amount'
        );

        for (
            uint256 poolId = poolGroup.firstPoolId + loanRecord.loanTerm;
            poolId <= poolGroup.firstPoolId + poolGroup.numPools;
            poolId++
        ) {
            if (remainingLoanAmount == 0) {
                break;
            }

            Pool storage pool = poolGroup.poolsById[poolId];

            if (pool.availableAmount == 0) {
                continue;
            }

            uint256 loanAmountFromPool = Math.min(
                remainingLoanAmount,
                pool.availableAmount
            );
            uint256 loanInterestToPool = loanRecord
                .interest
                .mulFixed(loanAmountFromPool)
                .divFixed(loanRecord.loanAmount);

            pool.borrowedAmount = pool.borrowedAmount.add(loanAmountFromPool);
            pool.availableAmount = pool.availableAmount.sub(loanAmountFromPool);
            pool.loanInterest = pool.loanInterest.add(loanInterestToPool);

            // Record the actual pool we loan from, so we know which pool to repay back later
            loanRecord.loanAmountByPool[poolId] = loanAmountFromPool;

            remainingLoanAmount = remainingLoanAmount.sub(loanAmountFromPool);
        }
    }

    function repayLoanToPools(
        State storage self,
        LoanManager.LoanRecord storage loanRecord,
        uint256 repayAmount
    ) external {
        PoolGroup storage poolGroup = self.poolGroups[loanRecord
            .loanTokenAddress];

        uint256 remainingRepayAmount = repayAmount;

        // Repay loan back to each pool, proportional to the total loan from all pools
        for (
            uint256 poolId = poolGroup.firstPoolId;
            poolId <= poolGroup.firstPoolId + poolGroup.numPools;
            poolId++
        ) {
            if (remainingRepayAmount == 0) {
                break;
            }

            uint256 loanAmountFromThisPool = loanRecord
                .loanAmountByPool[poolId];

            if (loanAmountFromThisPool == 0) {
                // Skip this pool since it has no loan
                continue;
            }

            /// Calculate the amount to repay to this pool, e.g., if I loaned total of 100
            /// from all pools, where 10 is from this pool, and I want to repay 50 now.
            /// Then the amount pay back to this pool will be: 50 * 10 / 100 = 5
            uint256 repayAmountToThisPool = repayAmount
                .mulFixed(loanAmountFromThisPool)
                .divFixed(loanRecord.loanAmount);

            Pool storage pool = poolGroup.poolsById[poolId];
            pool.availableAmount = pool.availableAmount.add(
                repayAmountToThisPool
            );
            pool.borrowedAmount = pool.borrowedAmount.sub(
                repayAmountToThisPool
            );

            remainingRepayAmount = remainingRepayAmount.sub(
                repayAmountToThisPool
            );
        }
    }

    function getPool(
        State storage self,
        address tokenAddress,
        uint256 poolIndex
    )
        external
        view
        returns (
            uint256 depositAmount,
            uint256 borrowedAmount,
            uint256 availableAmount,
            uint256 loanInterest,
            uint256 totalDepositWeight
        )
    {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        return
            getPoolById(self, tokenAddress, poolGroup.firstPoolId + poolIndex);
    }

    function getPoolById(
        State storage self,
        address tokenAddress,
        uint256 poolId
    )
        public
        view
        returns (
            uint256 depositAmount,
            uint256 borrowedAmount,
            uint256 availableAmount,
            uint256 loanInterest,
            uint256 totalDepositWeight
        )
    {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        Pool storage pool = poolGroup.poolsById[poolId];

        return (
            pool.depositAmount,
            pool.borrowedAmount,
            pool.availableAmount,
            pool.loanInterest,
            pool.totalDepositWeight
        );
    }

    function getDetailsFromAllPools(State storage self, address tokenAddress)
        external
        view
        returns (
            uint256[] memory poolIdList,
            uint256[] memory depositAmountList,
            uint256[] memory availableAmountList,
            uint256[] memory loanInterestList,
            uint256[] memory totalDepositWeightList
        )
    {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        poolIdList = new uint256[](poolGroup.numPools + 1);
        depositAmountList = new uint256[](poolGroup.numPools + 1);
        availableAmountList = new uint256[](poolGroup.numPools + 1);
        loanInterestList = new uint256[](poolGroup.numPools + 1);
        totalDepositWeightList = new uint256[](poolGroup.numPools + 1);

        for (
            uint256 poolIndex = 0;
            poolIndex <= poolGroup.numPools;
            poolIndex++
        ) {
            uint256 poolId = poolGroup.firstPoolId + poolIndex;
            poolIdList[poolIndex] = poolId;
            depositAmountList[poolIndex] = poolGroup.poolsById[poolId]
                .depositAmount;
            loanInterestList[poolIndex] = poolGroup.poolsById[poolId]
                .loanInterest;
            availableAmountList[poolIndex] = poolGroup.poolsById[poolId]
                .availableAmount;
            totalDepositWeightList[poolIndex] = poolGroup.poolsById[poolId]
                .totalDepositWeight;
        }

        return (
            poolIdList,
            depositAmountList,
            availableAmountList,
            loanInterestList,
            totalDepositWeightList
        );
    }

    function getAvailableAmountByLoanTerm(
        State storage self,
        address tokenAddress,
        uint256 loanTerm
    ) public view returns (uint256 availableAmountByLoanTerm) {
        PoolGroup storage poolGroup = self.poolGroups[tokenAddress];
        uint256 availableAmount;

        for (
            uint256 poolIndex = loanTerm;
            poolIndex <= poolGroup.numPools;
            poolIndex++
        ) {
            uint256 poolId = poolGroup.firstPoolId + poolIndex;
            availableAmount = availableAmount.add(
                poolGroup.poolsById[poolId].availableAmount
            );
        }

        return availableAmount;
    }
}
