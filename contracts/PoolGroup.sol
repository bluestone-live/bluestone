pragma solidity ^0.5.0;

import "openzeppelin-solidity/contracts/math/SafeMath.sol";

/// A group of pools where each pool stores information on deposit and loanable 
/// amount. The number of pools for each PoolGroup is defined by the deposit term.
/// 
/// - Pool ID: an internal identifier used to lookup a Pool struct. 
/// - Pool Index: used to mark the pool position, starting from 0. For example, 
///     a pool group of size 30 includes pool indices from 0 to 29, respectively.
contract PoolGroup {
    using SafeMath for uint;

    // Total deposit amount since the creation of this PoolGroup
    uint public totalDeposit;

    // Total loan amount since the creation of this PoolGroup
    uint public totalLoan;

    /// Total repaid loan amount since the creation of this PoolGroup. 
    /// It could be greater than totalLoan since it also includes 
    /// loan interest.
    uint public totalRepaid;

    // Total amount that is available for loan
    uint public totalLoanableAmount;

    // The total amount that has loaned to each loan term
    mapping(uint8 => uint) public totalLoanPerTerm;

    // The total amount that has repaid to each loan term
    mapping(uint8 => uint) public totalRepaidPerTerm;

    struct Pool {
        // Non-recurring deposit that matures once the term has been reached and available for withdraw
        uint oneTimeDeposit;

        // Recurring deposit that renews once the term has been reached and not available for withdraw
        uint recurringDeposit;

        // Total amount that can be loaned out
        uint loanableAmount;

        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint loanInterest;
    }

    /// A static array initialized to actual pools, where each pool is identified by an ID.
    Pool[] public poolsById;

    /// Given a pool index, it resolves to a pool ID. Basically it stores all pool IDs 
    /// which get updated after one day to reflect the maturity change. For example, 
    /// for a pool group of size 30, this is how pool IDs changing overtime:
    ///
    /// 1st day: [0, 1, 2, ..., 27, 28, 29]
    /// 2nd day: [1, 2, 3, ..., 28, 29, 0]
    /// 3rd day: [2, 3, 4, ..., 29, 0, 1]
    /// â€¦
    /// 30th day: [29, 0, 1, ..., 26, 27, 28]
    uint8[] public poolIds;

    constructor(uint8 term) public {
        for (uint8 i = 0; i < term; i++) {
            poolsById.push(Pool({
                oneTimeDeposit: 0,
                recurringDeposit: 0,
                loanableAmount: 0,
                loanInterest: 0
            }));

            poolIds.push(i);
        }
    }

    function getTotalLoanAfterRepay() external view returns (uint) {
        if (totalLoan > totalRepaid) {
            return totalLoan.sub(totalRepaid);
        } else {
            return 0;
        }
    }

    function getTotalLoanAfterRepayPerTerm(uint8 loanTerm) external view returns (uint) {
        if (totalLoanPerTerm[loanTerm] > totalRepaidPerTerm[loanTerm]) {
            return totalLoanPerTerm[loanTerm].sub(totalRepaidPerTerm[loanTerm]);
        } else {
            return 0;
        }
    }

    function getOneTimeDepositFromPool(uint8 index) public view returns (uint) {
        uint8 poolId = poolIds[index];
        return poolsById[poolId].oneTimeDeposit;
    }

    function getRecurringDepositFromPool(uint8 index) public view returns (uint) {
        uint8 poolId = poolIds[index];
        return poolsById[poolId].recurringDeposit;
    }

    function getTotalDepositFromPool(uint8 index) external view returns (uint) {
        return getOneTimeDepositFromPool(index).add(getRecurringDepositFromPool(index));
    }

    function getLoanableAmountFromPool(uint8 index) external view returns (uint) {
        uint8 poolId = poolIds[index];
        return poolsById[poolId].loanableAmount;
    }

    function getLoanInterestFromPool(uint8 index) external view returns (uint) {
        uint8 poolId = poolIds[index];
        return poolsById[poolId].loanInterest;
    }

    function addOneTimeDepositToPool(uint8 index, uint amount) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.oneTimeDeposit = pool.oneTimeDeposit.add(amount); 
        pool.loanableAmount = pool.loanableAmount.add(amount);
        totalDeposit = totalDeposit.add(amount);
        totalLoanableAmount = totalLoanableAmount.add(amount);
    }

    function addRecurringDepositToPool(uint8 index, uint amount) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.recurringDeposit = pool.recurringDeposit.add(amount); 
        pool.loanableAmount = pool.loanableAmount.add(amount);
        totalDeposit = totalDeposit.add(amount);
        totalLoanableAmount = totalLoanableAmount.add(amount);
    }

    function withdrawOneTimeDepositFromPool(uint8 index, uint amount) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.oneTimeDeposit = pool.oneTimeDeposit.sub(amount);
        pool.loanableAmount = pool.loanableAmount.sub(amount);
        totalDeposit = totalDeposit.sub(amount);
        totalLoanableAmount = totalLoanableAmount.sub(amount);
    }

    function loanFromPool(uint8 index, uint amount, uint interest, uint8 loanTerm) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.loanableAmount = pool.loanableAmount.sub(amount);
        totalLoan = totalLoan.add(amount);
        totalLoanableAmount = totalLoanableAmount.sub(amount);
        totalLoanPerTerm[loanTerm] = totalLoanPerTerm[loanTerm].add(amount);
        pool.loanInterest = pool.loanInterest.add(interest);
    }

    function repayLoanToPool(uint8 index, uint amount, uint8 loanTerm) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.loanableAmount = pool.loanableAmount.add(amount);
        totalRepaid = totalRepaid.add(amount);
        totalLoanableAmount = totalLoanableAmount.add(amount);
        totalRepaidPerTerm[loanTerm] = totalRepaidPerTerm[loanTerm].add(amount);
    }

    function clearLoanInterestFromPool(uint8 index) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.loanInterest = 0;
    }

    function transferRecurringDepositToOneTimeDeposit(uint8 index, uint amount) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.recurringDeposit = pool.recurringDeposit.sub(amount);
        pool.oneTimeDeposit = pool.oneTimeDeposit.add(amount);
    }

    function transferOneTimeDepositToRecurringDeposit(uint8 index, uint amount) external {
        uint8 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.oneTimeDeposit = pool.oneTimeDeposit.sub(amount);
        pool.recurringDeposit = pool.recurringDeposit.add(amount);
    }

    /// Update pool ID at each index to reflect the maturity change of the pools using formula:
    /// poolId = (poolId + 1) % poolGroup.length
    function updatePoolIds() external {
        for (uint8 i = 0; i < poolIds.length; i++) {
            poolIds[i] = (poolIds[i] + 1) % uint8(poolIds.length);           
        }
    }
}
