pragma solidity ^0.5.0;

import 'openzeppelin-solidity/contracts/math/SafeMath.sol';

/// A group of pools where each pool stores information on deposit and loanable
/// amount. The number of pools for each PoolGroup is defined by the deposit term.
///
/// - Pool ID: an internal identifier used to lookup a Pool struct.
/// - Pool Index: used to mark the pool position, starting from 0. For example,
///     a pool group of size 30 includes pool indices from 0 to 29, respectively.
contract PoolGroup {
    using SafeMath for uint256;

    // ANALYTICAL DATA ------------------------------------------------------------------------

    // Total deposit amount since the creation of this PoolGroup
    uint256 public totalDeposit;

    // Total loan amount since the creation of this PoolGroup
    uint256 public totalLoan;

    /// Total repaid loan amount since the creation of this PoolGroup.
    /// It could be greater than totalLoan since it also includes
    /// loan interest.
    uint256 public totalRepaid;

    // The total amount that has loaned to each loan term since the creation of this PoolGroup.
    mapping(uint256 => uint256) public totalLoanPerTerm;

    // The total amount that has repaid to each loan term since the creation of this PoolGroup.
    mapping(uint256 => uint256) public totalRepaidPerTerm;

    // ----------------------------------------------------------------------------------------

    // Total amount that is available for loan
    uint256 public totalLoanableAmount;

    /// Total amount that is available for loan on each loan term
    mapping(uint256 => uint256) public totalLoanableAmountPerTerm;

    struct Pool {
        uint256 deposit;
        // Total amount that can be loaned out
        uint256 loanableAmount;
        /// We add loan interest generated by a specific loan amount from this pool.
        /// It will be used to calculate interest for whom deposited to this pool.
        uint256 loanInterest;
    }

    /// A static array initialized to actual pools, where each pool is identified by an ID.
    Pool[] public poolsById;

    /// Given a pool index, it resolves to a pool ID. Basically it stores all pool IDs
    /// which get updated after one day to reflect the maturity change. For example,
    /// for a pool group of size 30, this is how pool IDs changing overtime:
    ///
    /// 1st day: [0, 1, 2, ..., 27, 28, 29]
    /// 2nd day: [1, 2, 3, ..., 28, 29, 0]
    /// 3rd day: [2, 3, 4, ..., 29, 0, 1]
    /// â€¦
    /// 30th day: [29, 0, 1, ..., 26, 27, 28]
    uint256[] public poolIds;

    constructor(uint256 term) public {
        for (uint256 i = 0; i < term; i++) {
            poolsById.push(
                Pool({ deposit: 0, loanableAmount: 0, loanInterest: 0 })
            );

            poolIds.push(i);
        }
    }

    function getTotalLoanAfterRepay() external view returns (uint256) {
        if (totalLoan > totalRepaid) {
            return totalLoan.sub(totalRepaid);
        } else {
            return 0;
        }
    }

    function getTotalLoanAfterRepayPerTerm(uint256 loanTerm)
        external
        view
        returns (uint256)
    {
        if (totalLoanPerTerm[loanTerm] > totalRepaidPerTerm[loanTerm]) {
            return totalLoanPerTerm[loanTerm].sub(totalRepaidPerTerm[loanTerm]);
        } else {
            return 0;
        }
    }

    function setTotalLoanableAmountPerTerm(uint256 loanTerm, uint256 amount)
        external
    {
        totalLoanableAmountPerTerm[loanTerm] = amount;
    }

    function addTotalLoanableAmountPerTerm(uint256 loanTerm, uint256 amount)
        external
    {
        totalLoanableAmountPerTerm[loanTerm] = totalLoanableAmountPerTerm[loanTerm]
            .add(amount);
    }

    function subtractTotalLoanableAmountPerTerm(
        uint256 loanTerm,
        uint256 amount
    ) external {
        totalLoanableAmountPerTerm[loanTerm] = totalLoanableAmountPerTerm[loanTerm]
            .sub(amount);
    }

    function getDepositFromPool(uint256 index) public view returns (uint256) {
        uint256 poolId = poolIds[index];
        return getDepositByPoolId(poolId);
    }

    function getDepositByPoolId(uint256 poolId) public view returns (uint256) {
        return poolsById[poolId].deposit;
    }

    function getLoanableAmountFromPool(uint256 index)
        external
        view
        returns (uint256)
    {
        uint256 poolId = poolIds[index];
        return poolsById[poolId].loanableAmount;
    }

    function getLoanableAmountFromPoolByPoolId(uint256 poolId)
        external
        view
        returns (uint256)
    {
        return poolsById[poolId].loanableAmount;
    }

    function getLoanInterestFromPool(uint256 index)
        external
        view
        returns (uint256)
    {
        uint256 poolId = poolIds[index];
        return getLoanInterestByPoolId(poolId);
    }

    function getLoanInterestByPoolId(uint256 poolId)
        public
        view
        returns (uint256)
    {
        return poolsById[poolId].loanInterest;
    }

    /// getDaysAfterDepositCreation computes how many days past after deposit being created by counting how many step the poolId shift.
    ///
    /// 1st day: [0, 1, 2, ..., 27, 28, 29], deposit created on this day, so `getDaysAfterDepositCreation` returns 0
    /// because 0 day past after creation
    /// 2nd day: [1, 2, 3, ..., 28, 29, 0], `getDaysAfterDepositCreation` returns 1
    /// because 1 day past after creation.
    /// 3rd day: [2, 3, 4, ..., 29, 0, 1], `getDaysAfterDepositCreation` returns 2
    /// because 2 days past after creation.
    /// ...
    /// 30th day: [29, 0, 1, ..., 26, 27, 28], `getDaysAfterDepositCreation` returns 29
    /// because 29 days past after creation.
    /// If poolId is not in poolIds, getDaysAfterDepositCreation will return term which is 30 in example.
    function getDaysAfterDepositCreation(uint256 poolIdOfDeposit)
        external
        view
        returns (uint256)
    {
        uint256 depositTerm = poolIds.length;
        uint256 daysAfterDepositCreation = 0;
        uint256 i = depositTerm - 1;
        while (i > 0 && poolIds[i] != poolIdOfDeposit) {
            daysAfterDepositCreation++;
            i--;
        }
        if (i == 0 && poolIds[i] != poolIdOfDeposit) {
            daysAfterDepositCreation++;
        }
        return daysAfterDepositCreation;
    }

    function addDepositToPool(uint256 index, uint256 amount) external {
        uint256 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.deposit = pool.deposit.add(amount);
        pool.loanableAmount = pool.loanableAmount.add(amount);
        totalDeposit = totalDeposit.add(amount);
        totalLoanableAmount = totalLoanableAmount.add(amount);
    }

    function subDepositFromPool(uint256 poolId, uint256 amount) external {
        Pool storage pool = poolsById[poolId];
        pool.deposit = pool.deposit.sub(amount);
        pool.loanableAmount = pool.loanableAmount.sub(amount);
        totalDeposit = totalDeposit.sub(amount);
        totalLoanableAmount = totalLoanableAmount.sub(amount);
    }

    function loanFromPool(
        uint256 index,
        uint256 amount,
        uint256 interest,
        uint256 loanTerm
    ) external {
        uint256 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.loanableAmount = pool.loanableAmount.sub(amount);
        totalLoan = totalLoan.add(amount);
        totalLoanableAmount = totalLoanableAmount.sub(amount);
        totalLoanPerTerm[loanTerm] = totalLoanPerTerm[loanTerm].add(amount);
        pool.loanInterest = pool.loanInterest.add(interest);
    }

    function repayLoanToPool(uint256 index, uint256 amount, uint256 loanTerm)
        external
    {
        uint256 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.loanableAmount = pool.loanableAmount.add(amount);
        totalRepaid = totalRepaid.add(amount);
        totalLoanableAmount = totalLoanableAmount.add(amount);
        totalRepaidPerTerm[loanTerm] = totalRepaidPerTerm[loanTerm].add(amount);
    }

    function clearDepositFromPool(uint256 index) external {
        uint256 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.deposit = 0;
    }

    function clearLoanInterestFromPool(uint256 index) external {
        uint256 poolId = poolIds[index];
        Pool storage pool = poolsById[poolId];
        pool.loanInterest = 0;
    }

    /// Update pool ID at each index to reflect the maturity change of the pools using formula:
    /// poolId = (poolId + 1) % poolGroup.length
    function updatePoolIds() external {
        for (uint256 i = 0; i < poolIds.length; i++) {
            poolIds[i] = (poolIds[i] + 1) % poolIds.length;
        }
    }
}
